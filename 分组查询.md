# ==分组查询==

这里先列出来一些常用的比较简单的sql查询语句

## 基本结构：

`SELECT 列名/所有列*/函数 FROM 表名1,表名2... [WHERE 过滤行的条件] [GROUP BY 分组列名] [HAVING 过滤条件] [ORDER BY 排序列] `



```sql
SELECT * FROM student WHERE sex='女';
SELECT * FROM student WHERE sex='男';

```



```SQL
#查询在网安一班的学生的信息
SELECT * FROM student WHERE classid='S01';

#查询在网安一班学习的学生的姓名和电话号码
SELECT sname,phone FROM student WHERE classid='S01';

#查询在网安一班学习的女生的信息
SELECT * FROM student WHERE classid='S01' AND sex='女';

#查询在测试二班学习的男生并且年龄在25岁以上的
SELECT * FROM student WHERE classid='T02' AND age>25 AND sex='男';

#查询不是本科学历的学生
SELECT * FROM student WHERE degree != '本科';
SELECT * FROM student WHERE degree <> '本科';
SELECT * FROM student WHERE student IN ('研究生','大专');

```



```sql
#排序
SELECT * FROM student WHERE age > 25; #默认并没有排序，只是原始的行的顺序

SELECT * FROM student WHERE age > 25 ORDER BY age ASC;  #按照age从小到大排序

SELECT * FROM student WHERE age > 25 ORDER BY age DESC;  #按照age从大到小排序

SELECT * FROM student WHERE age > 25 ORDER BY age DESC;  #直接按照列的序号进行排序

SELECT * FROM student WHERE age > 25 ORDER BY age,student DESC;

SELECT * FROM student WHERE age > 25 ORDER BY phone;
```



```sql
#去重
SELECT DISTINCT(classid) FROM student;  #确认一下是否有班级没有学生

SELECT DISTINCT(degree) FROM student;  #确认一下学生的学历分类

SELECT DISTINCT(age) FROM student ORDER BY age;
```



```sql
#查询学生成绩在90（包含）~100（包含）之间的
SELECT * FROM grade WHERE score BETWEEN 90 AND 100;

#针对上述的闭区域，可以使用 BETWEEN ... AND ...
SELECT * FROM grade WHERE score BETWEEN 90 AND 100;

#查询2021年5月份参加考试的学生成绩
SELECT * FROM grade WHERE 	createtime BETWEEN '2021-05-01 00:00:00' AND '2021-5031 23:59:59';

SELECT * FROM grade WHERE createtime BETWEEN '2021-05-01' AND '2021-05-31'; 
```



```sql
#单表的其他查询
SELECT MAX(age) FROM student;  #查询年龄最大的数字

SELECT * FROM student WHERE age=(SELECT MAX(age) FROM student);  #利用子查询，查询年龄最大的学生的信息
SELECT * FROM student WHERE age=(SELECT MIN(age) FROM student);  #利用子查询，查询年龄最小的学生的信息
```



```sql
#Like关键字做模糊查询
# 用%代替任意字符
# 用_代替一个字符
SELECT * FROM student WHERE sname Like '张%';  #从student表中查询姓名以张开头的学员

SELECT * FROM student WHERE sname Like '李_';  #从student这张表中查询出姓名只有两个字且以李姓开头的学生,要查三个字的话就用李__(两个短线)

#查询姓名中包含 子 的学员
SELECT * FROM student WHERE sname Like '%子%';  #记住，%代表任意字符，有和没有都可以

#查询一班学生的平均年龄
SELECT AVG(age) FROM student WHERE classid='S01';  #我们可以通过在 AVG() 后面添加新列名来决定我们查询结果的表的名称 [AS] 表示AS可要可不要
SELECT AVG(age) [AS] 平均年龄 FROM student WHERE classid='S01';
```

![image-20231129193151255](https://gitee.com/ymq_typroa/typroa/raw/main/image-20231129193151255.png)

![image-20231129193359028](https://gitee.com/ymq_typroa/typroa/raw/main/image-20231129193359028.png)

```sql
#统计某一个条件下的查询结果的行数
SELECT COUNT(age) FROM student;

#统计某个列的总和
SELECT SUM(age) FROM student;

#统计某个列的标准差
SELECT STD(age) FROM student;

#计算 C09课程 5月考试成绩的平均值
SELECT AVG(score) FROM student WHERE classid='C09' AND createtime BETWEEN '2021-05-01' and '2021-05-31';
```

![image-20231129195802402](https://gitee.com/ymq_typroa/typroa/raw/main/image-20231129195802402.png)

![image-20231129195821693](https://gitee.com/ymq_typroa/typroa/raw/main/image-20231129195821693.png)



```sql
#查询C01课程，考试成绩排名前10的学生
SELECT * FROM student WHERE classid='C01' ORDER BY score DESC LIMIT 10;

SELECT * FROM student WHERE classid='C01' ORDER BY score ASC LIMIT 10;

#熟练运用LIMIT语法
SELECT * FROM student WHERE classid='C01' LIMIT m,n; #查找班级id为C01，并从m+1条值往后查找n条信息。其中m是下标，n是要往后查询的条数。


#查询出排名前10的学生，但是如果有并列成绩。则查询出所有并列成绩的学生，及时超过10个

```



```sql
#分组查询

#查询每门学科的平均成绩
SELECT courseid AVG(score) AS AvgScore FROM grade GROUP BY courseid;
#GROUP BY 天生具有去重的功能，所以可以替代DISTINCT使用
#GROUP BY courseid 对classid去重分组
```

下面就是GROUP BY 的查询结果

![image-20231130092349737](https://gitee.com/ymq_typroa/typroa/raw/main/image-20231130092349737.png)

当然，使用DISTINCT(courseid)的结果和上面是一样的,用也就是下面的查询语句

```sql
SELECT DISTINCT(courseid) AVG(score) AS AvgScore FROM grade;
```



```sql
#查询平均成绩最高和最低的课程
SELECT courseid AVG(score) AS AvgScore FROM grade GROUP BY courseid ORDER BY DESC AvgScore LIMIT 1;


SELECT courseid AVG(score) AS AvgScore FROM grade GROUP BY courseid ORDER BY AvgScore LIMIT 1;
#ORDER BY 默认升序向下排序，此时对AvgScore进行默认升序向下排序
#GROUP BY 对 courseid进行分组去重
```



```sql
#查询平均成绩在70分以上的课程
#一、需要注意 WHERE 不能用在GROUP BY后面，否则就要报错
SELECT courseid AVG(score) AS AvgScore FROM grade GROUP BY courseid WHERE AvgScore >= 70;

#二、需要注意WHERE也不能在GROUP BY 前面用，该错误我们可以理解为，GROUP BY 还没去重分组完成呢就要开始WHERE查询了，这不是很荒唐
SELECT courseid AVG(score) AS AvgScore FROM grade WHERE AvgScore >= 70 GROUP BY courseid;
```

下面这张图是WHERE放在了 GROUP BY 后面所报的错误

![image-20231130094508090](https://gitee.com/ymq_typroa/typroa/raw/main/image-20231130094508090.png)

 下面这张图是WHERE 用在了 GROUP BY 的前面所导致的问题![image-20231130094731730](https://gitee.com/ymq_typroa/typroa/raw/main/image-20231130094731730.png)

**此时我们就需要使用HAVING关键字**

```sql
SELECT courseid AVG(score) AS AvgScore FROM grade GROUP BY courseid HAVING AvgScore >= 70;
#对 GROUP BY 聚合函数的结果进行二次过滤时，我们使用HAVING关键字
```

下面是我们使用`HAVING`对`GROUP BY`聚合函数的结果进行二次查询的结果

![image-20231130095806086](https://gitee.com/ymq_typroa/typroa/raw/main/image-20231130095806086.png)





```sql
#分组查询可以正对多列进行分组查询
SELECT sex,degree,AVG(age) FROM student GROUP BY sex,degree;
#先对性别进行分组去重然后再对学历进行分组去重，最后查询结果由性别，学历，平均年龄三者构成
```

![image-20231130100409707](https://gitee.com/ymq_typroa/typroa/raw/main/image-20231130100409707.png)

```sql
SELECT degree,sex,AVG(age) FROM student GROUP BY degree,sex;
```

![image-20231130100633917](https://gitee.com/ymq_typroa/typroa/raw/main/image-20231130100633917.png)

这就是使用 GROUP BY 进行分组查询的不同使用的区别
