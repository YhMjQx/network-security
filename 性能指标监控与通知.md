# ==性能指标监控与通知==

系统的性能指标监控室比较常见的针对系统的管理场景，比如系统有挖矿程序，或者系统本身存在高CPU进程（正常应用），除了CPU以外，也可以监控内存，硬盘，网络流量等使用情况。通过监控和发送通知，可以及时对系统的运行情况进行把控，进而实现正确的处置。如果发现某些异常CPU消耗，森只可以直接结束掉进程。

（1）通过相应的命令能够输出需要的指标

（2）通过awk对输出结果进行过滤，找到对应的值

（3）根据对应的值进行判断，进而决定后续处理方式

## 一、使用yes程序监控CPU 

### 1.通过总cpu来测试

![image-20231013161915535](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20231013161915535.png)

![image-20231013161929492](https://gitee.com/ymq_typroa/typroa/raw/main/image-20231013161929492.png)

![image-20231013161951542](https://gitee.com/ymq_typroa/typroa/raw/main/image-20231013161951542.png)

 ```shell
 top -n 1 	#查看cpu使用情况
 
 top -n 1 | grep ^%Cpu 	#找到以%Cpu开头的行
 
 top -n 1 | grep ^%Cpu | awk '{print int($8)}' 	#在以%Cpu开头的行中筛选出cpu的使用情况
 
 cpu=$(top -n 1 | grep ^%Cpu | awk '{print int($8)}') 	#将筛选出的结果赋值给cpu这个变量，注意，这里需要将$8这个变量的值转为整数，通过 int() 这是一种方法，还有一种方法是 再次使用 awk ,演示如下： `cpu=$(top -n 1 | grep ^%Cpu | awk '{print int$8}' | awk -F . '{print $1}')`
 
 [ $cpu -lt 85 ] 
 echo $? 	#两条命令判断结果是不是小于85
 
 ```

### 2.通过cpu的进程消耗测试

```shell
top -n 1 | sort -k 9 -r 	#按 `top -n 1` 中第9栏的结果降序排列，最终得到的最小号的进程就在最上面
或
ps aux | sort -k 3 -r 	#和上面的意思差不多，也是降序排列，第一行的就是cpu进程消耗最高的

ps aux | sort -k 3 -r | head -n 2 | tail -n 1 	#这个结果就是将上面的cpu进程消耗最高的过滤出来

ps aux | sort -k 3 -r | head -n 2 | tail -n 1 | awk '{print $3}' 	#打印出cpu的最消耗的进程率

ps aux | sort -k 3 -r | head -n 2 | tail -n 1 | awk '{print $2}' 	#打印出最消耗cpu的进程id

pcpu=`ps aux | sort -k 3 -r | head -n 2 | tail -n 1 | awk '{print $3}'`
echo $pcpu / 4 | bc
#两条命令计算出真正的cpu使用率，因为总的cpu使用率和电脑核数有关，这里的这个4就是核数
```

![image-20231013163350450](https://gitee.com/ymq_typroa/typroa/raw/main/image-20231013163350450.png)

如图，这里所展示的 98.2 是cpu的使用率，但也只是一个核的使用率，要想计算总的cpu的使用率，还需要将 98.2 除以 4。不然为什么最上面图中总的cpu还剩下 86.5 但是到了这里却变成了 使用了 98.2 ，就是因为还需要除以核数，而我的核数是 8 ，也就是说 单核cpu 和 总cpu 我们看结果

![image-20231013163911793](https://gitee.com/ymq_typroa/typroa/raw/main/image-20231013163911793.png)

结果是使用了 24% 的cpu 和 86%一加刚好就是 100%

### 3.如何收集内存使用信息

#### 方法一：

获取空闲内存大小

![image-20231013164610552](https://gitee.com/ymq_typroa/typroa/raw/main/image-20231013164610552.png)

![image-20231013164603986](https://gitee.com/ymq_typroa/typroa/raw/main/image-20231013164603986.png)

```shell
在这里我就写的简单一点了
top -n 1 | grep "^KiB Mem" | awk '{print $6}'
```

方法二：

free指令中直接就有空闲内存空间大小，像什么总共的，使用了的，空闲的，共享的，缓存的，可使用的都有

![image-20231013164721258](https://gitee.com/ymq_typroa/typroa/raw/main/image-20231013164721258.png)

### 4.如何收集硬盘信息

![image-20231013165412502](https://gitee.com/ymq_typroa/typroa/raw/main/image-20231013165412502.png)

```shell
df -h | grep ^/dev/mapper
```

### 5.如何收集网卡流量情况

首先我们需要知道如何查看网卡上的流量情况

```shell
ip -s link 	#查看网卡的收发数据报大小， RX：收，TX：发

ifconfig -s 	#同上
```

其他的情况和上面的的使用方法就是一样的

我们现在来综合一下：

```shell
cpu=$(top -n 1 | grep ^%Cpu | awk '{print int($8)}')
if [ $cpu -lt 85 ]; then
        pcpu=$(ps aux | sort -k 3 -r | head -n 2 | tail -n 1 | awk '{print $3}')
        ppcpu=$(echo $pcpu / 4 | bc)
        pid=$(ps aux | sort -k 3 -r | head -n 2 | tail -n 1 | awk '{print $2}')
        echo "CPU is lower , $pid consume $ppcpu%"
else
        echo "CPU is OK"
fi
或
cpu=$(top -n 1 | grep ^%Cpu | awk '{print int($8)}')
if [ $cpu -lt 85 ]; then
        pcpu=`ps aux | sort -k 3 -r | head -n 2 | tail -n 1 | awk '{print $3}'`
        ppcpu=$(echo $pcpu / 4 | bc)
        pid=`ps aux | sort -k 3 -r | head -n 2 | tail -n 1 | awk '{print $2}'`
        echo "CPU is lower , $pid consume $ppcpu%"
else
        echo "CPU is OK"
fi
二者区别在于给 ppcpu 和 pid 赋值的时候 上面使用的是 $() 而下面使用的是 `` 这个符号，表示计算表达式
```

