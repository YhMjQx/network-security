# ==MISC36==

![image-20230921222741150](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230921222741150.png)

我们按照正常的图片，也就是没有修改过的照片，直接进行gif爆破得到的图片全都是

![image-20230921223506663](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230921223506663.png)

这样的，我们可以感觉到应该还是宽高有问题，我们去修改一下再试试

我将宽度由900改为935

![image-20230921223713339](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230921223713339.png)

得到的结果还是这样，这到底是怎么回事

而且我们就算不通过帧图片分离直接查看原图，将宽度修改之后得到的图片和原图除了宽度变了，其他一点没变

我们想一下以前遇到这种情况是为什么，想想为什么宽度变了原图还是没有一点有关flag的信息呢

会不会是因为...别忘了高度！！！注意，当你发现不管怎样修改宽度都无法得到有关flag的任何信息，就再去考虑一下高度的问题，有可能flag就在下面

我们继续将高度改大一点，注意注意，这里是两个数据宽高块，一定要都修改了！！！

![image-20230921232407109](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230921232407109.png)

然后进行gif爆破，此时就可以得到![image-20230921232535418](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230921232535418.png)

# ==MISC37==

![image-20230922134808119](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230922134808119.png)

emmmm这个题目。。。

我还傻乎乎的将每一帧的图片的高度全都修改了，然后去进行gif爆破，好好好，没想到爆破出来的图片什么都没有

然后才去网上找了个在线的gif图片分离工具，将图片分离出来，看来这个在线的分离工具还有好用些，当脚本爆破分离不出来的时候，就尝试用一下这个在线的工具，然后就得到了以下的信息

![image-20230922163000438](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230922163000438.png)

![image-20230922142755511](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230922142755511.png)

![image-20230922142747898](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230922142747898.png)

![image-20230922142805644](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230922142805644.png)

![image-20230922142811635](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230922142811635.png)

![image-20230922142817233](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230922142817233.png)

拼接在一起就是ctfshow{2056782cd57b13261dcbbe3d6eecda17}

# ==MISC38==

![image-20230922143104868](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230922143104868.png)

好好好，没想到这竟然是一个apng图片，是怎么区分的呢？？？

```
			文件扩展名说明
			 * 255216 jpg
             * 208207 doc xls ppt wps
             * 8075 docx pptx xlsx zip
             * 5150 txt
             * 8297 rar
             * 7790 exe
             * 3780 pdf      
             * 
             * 4946/104116 txt
             * 7173        gif 
             * 255216      jpg
             * 13780       png
             * 6677        bmp文件扩展名说明
             * 255216 jpg
             * 208207 doc xls ppt wps
             * 8075 docx pptx xlsx zip
             * 5150 txt
             * 8297 rar
             * 7790 exe
             * 3780 pdf      
             * 
             * 4946/104116 txt
             * 7173        gif 
             * 255216      jpg
             * 13780       png
             * 1378097998476   apng
             * 6677        bmp
             * 239187      txt,aspx,asp,sql
             * 208207      xls.doc.ppt
             * 6063        xml
             * 6033        htm,html
             * 4742        js
             * 8075        xlsx,zip,pptx,mmap,zip
             * 8297        rar   
             * 01          accdb,mdb
             * 7790        exe,dll
             * 5666        psd 
             * 255254      rdp 
             * 10056       bt种子 
             * 64101       bat 
             * 4059        sgf
             * 239187      txt,aspx,asp,sql
             * 208207      xls.doc.ppt
             * 6063        xml
             * 6033        htm,html
             * 4742        js
             * 8075        xlsx,zip,pptx,mmap,zip
             * 8297        rar   
             * 01          accdb,mdb
             * 7790        exe,dll
             * 5666        psd 
             * 255254      rdp 
             * 10056       bt种子 
             * 64101       bat 
             * 4059        sgf
```

![image-20230922163658272](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230922163658272.png)

注意看这里，真正的apng图片在37-40字节之间会有这么一个标识符，apng图片的文件结构中还有一个名为acTL的标识符，它在第37到40个字节之间的值是关键。我们可以通过这样的方法来区分两种图片类型

发现这竟然是一个apng图片，是属于png的动图，这种情况我们要使用工具apngdis，将每一帧的图片分离出来

![image-20230922162008788](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230922162008788.png)

就变成了这样

我们使用honeyview去查看

![image-20230922162053413](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230922162053413.png)

![image-20230922162059625](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230922162059625.png)

![image-20230922162115515](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230922162115515.png)

![image-20230922162125813](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230922162125813.png)

拼接之后的结果就是 ctfshow{48b722b570c603ef58cc0b83bbf7680d}

# ==MISC39==

![image-20230922164019817](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230922164019817.png)

将 gif图片直接爆破分离出来之后，得到的全都是gif动图，但是里面根本不含任何flag信息

![image-20230922204156291](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230922204156291.png)

尝试改宽高，但是一想，里面嵌套的gif动图太多了，根本不可能让你去改宽高，不会有这么无脑且傻的题目

那我们该怎么办呢？？？尝试以前的方法？？？

binwalk  没有

![image-20230922204922013](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230922204922013.png)

zsteg  没有

![image-20230922205052019](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230922205052019.png)

这是gif图，所以也不用考虑exiftool了

那么这题该怎么做？？？好了，又该学习新知识了

这题也是一个gif，不过这里是利用`不同帧之间的间隔时间`来隐写的。这该怎么做啊！！！

这里要用到的是Linux下的一个工具，叫做  identify

首先需要安装，因为我是第一次用

> 使用命令 `identify -format "%T " /root/桌面/misc39.gif > 1.txt`，然后会输出一个 1.txt 文件，里面存储了一串数据，也不知道是干什么用的文件，记录的是什么数据
>
> 在Kali中运行`identify -format "%T " /root/桌面/misc39.gif > 1.txt`命令时，输出的`1.txt`文件并不包含图像类型数据。
>
> 实际上，`identify`命令是ImageMagick图像处理工具集的一部分，它主要用于获取图像文件的详细信息，而不是获取图像类型。
>
> 对于GIF图像文件，`identify`命令将会输出有关该图像文件的详细信息，例如图像的宽度、高度、颜色等。如果您想要获取GIF图像文件的具体类型信息，您可以尝试使用其他工具，如`file`命令或通过分析文件扩展名进行判断。对于`misc39.gif`文件而言，它的文件扩展名 “.gif” 已经明确表示了它是一个GIF图像文件。

之后我们打开这个文件

![image-20230922212653780](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230922212653780.png)

发现全都是37和36，这又是想表达什么呢？？？接下来又该怎么做？？？

网上告诉我将37换为1,36换为0，**就得到长度为`287`的二进制字符串，考虑每`7`位转一个字符(正常是`8`位一组)，得到`flag`。**

靠，为什么啊？？？



**但是**如果我将37换为0,36换为1呢，结果又是怎样的？？？

> 0 0 1 1 1 0 0 0 0 0 1 0 1 1 0 0 1 1 0 0 1 0 0 0 1 1 0 0 0 0 1 0 1 1 1 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 1 1 0 1 1 0 0 0 1 1 1 1 0 0 1 1 1 0 1 0 0 1 1 0 1 0 0 1 1 0 0 1 0 0 1 1 0 0 1 1 0 0 0 1 1 0 1 0 0 0 1 1 0 1 0 0 1 0 1 0 0 0 1 1 0 0 1 0 0 1 1 1 0 1 1 0 0 1 0 0 0 0 0 1 1 1 0 1 0 0 1 1 0 1 0 1 0 0 1 1 0 1 1 0 0 1 0 0 1 1 0 0 0 1 1 1 0 0 1 1 0 1 1 1 0 0 0 1 1 0 1 0 0 1 0 0 1 1 0 0 1 1 0 0 0 0 1 1 1 1 0 1 0 0 0 1 1 0 0 0 1 1 0 1 0 0 0 1 1 1 0 1 0 0 1 1 1 0 0 0 0 1 1 1 1 0 1 0 0 1 1 1 1 1 0 0 1 0 1 1 1 0 0 1 0 1 0 1 0 0 0 1 1 0 0 0 0 0 0 1 0

会得到这么一串二进制数据

使用脚本（而且这个脚本为什么是7个bit位一个字符？？？）

![image-20230922214941893](https://gitee.com/ymq_typroa/typroa/raw/main/image-20230922214941893.png)

==在处理二进制数据时，以7个bit位为一个字符而不是8个bit位一个字符的原因可能涉及到特定的编码方案或传输协议。在某些情况下，可能有以下原因：==

==节省空间：在某些应用中，空间可能非常宝贵。使用7个bit位而不是8个bit位可能意味着在存储或传输相同数量信息时，可以节省一定的空间。==
==兼容性：某些旧的硬件或协议可能只支持7个bit位作为一个字符。为了保持与这些旧系统兼容，可能会选择继续使用7个bit位。
字符集编码：特定的字符集编码可能使用7个bit位来表示一个字符。例如，在ASCII编码中，使用7个bit位来表示一个字符。==

==需要注意的是，在计算机科学中，通常以8个bit位为一个字符，这称为一个字节（Byte）。这是由于大多数现代计算机和操作系统都使用8个bit位来表示一个字节。在某些特定的应用中，可能会使用不同的长度来表示字符，例如在网络传输中可能会使用7个bit位作为一个字符，这是为了提高传输效率和节约带宽。==

==总之，选择使用7个bit位而不是8个bit位作为字符长度取决于特定应用的需求和限制。==

**原来还有这些可能，以前确实不知道，在这里很有可能是因为ASCII码值的问题**

好吧，此时得到的竟然是这样的结果，还是乖乖按照wp里面说的来做吧

至于关于到底是谁替换为0还是1这个问题，换两次就知道了，大不了就考虑谁大谁换1

将37换为1,36换为0

> 1 1 0 0 0 1 1 1 1 1 0 1 0 0 1 1 0 0 1 1 0 1 1 1 0 0 1 1 1 1 0 1 0 0 0 1 1 0 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 0 1 1 0 1 1 0 1 0 1 0 1 1 0 0 1 0 0 1 1 1 0 0 0 0 1 1 0 0 0 1 0 1 1 0 0 1 0 1 1 0 0 1 1 0 1 1 0 0 1 1 0 0 1 1 1 0 0 1 0 1 1 1 0 0 1 0 1 1 0 1 0 1 1 1 0 0 1 1 0 1 1 0 0 0 1 0 0 1 1 0 1 1 1 1 1 0 0 0 1 0 1 1 0 0 1 0 1 0 1 1 0 0 1 0 0 1 1 0 1 1 0 0 1 1 1 0 0 0 1 1 0 0 1 0 0 0 1 1 1 0 0 1 0 1 1 0 1 1 0 0 1 1 0 0 1 1 1 1 0 0 0 0 1 0 1 1 1 0 0 1 1 1 0 0 1 0 1 1 1 0 0 0 1 0 1 1 0 0 0 1 1 1 1 0 0 0 0 1 0 1 1 0 0 0 0 0 1 1 0 1 0 0 0 1 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1 0 1

然后就得到了这么一串二进制数据

然后使用脚本 

`s="11000111110100110011011100111101000110111111101111111011011010101100100111000011000101100101100110110011001110010111001011010111001101100010011011111000101100101011001001101100111000110010001110010110110011001111000010111001110010111000101100011110000101100000110100011010101110011111101"
flag=""
for i in range(41): #287//7
    flag += chr(int(s[7*i:7*(i+1)],2))
print(flag)`

爆破出flag即可





##### ==这是一个关于通过gif不同帧之间的时间间隔来达到信息隐藏的效果，这按理说已经算是比较难的了，这猴子那个时候需要用到 **identify** 这个工具，这个工具是集成在imagemagick里面的，他可以输出有关该图像文件的详细信息==

